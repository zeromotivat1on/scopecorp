#define STB_TRUETYPE_IMPLEMENTATION
#include "stb_truetype.h"

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"

#define STB_SPRINTF_IMPLEMENTATION
#include "stb_sprintf.h"

#include <stdio.h>

#define COUNT(a) (sizeof(a) / sizeof((a)[0]))

void bake_font_atlas(const char *in_path, int pixel_height, int width, int height) {
    static const char *tex_dir = "run_tree/data/textures/";
    static const char *src_dir = "src/fonts/";
    
    static unsigned char   ttf_buffer [1 << 22];
    static unsigned char   bitmap     [1 << 22];
    static stbtt_bakedchar cdata      [96];      // ASCII 32..126 is 95 glyphs
    static char            cdata_h    [1 << 20]; // buffer to write generated .h to

    char height_str [16]  = {0};
    char name       [64]  = {0};
    char png_path   [256] = {0};
    char h_path     [256] = {0};
    
    FILE *file = fopen(in_path, "rb");
    if (!file) {
        printf("Failed to open %s\n", in_path);
        return;
    }

    unsigned long long file_size = 0;
    fseek(file, 0, SEEK_END);
    file_size = ftell(file);
    rewind(file);

    if (file_size > sizeof(ttf_buffer)) {
        printf("Given font %s size %llu is too big for our ttf buffer of size %llu\n", in_path, file_size, sizeof(ttf_buffer));
        return;
    }
    
    const size_t bytes_read = fread(ttf_buffer, 1, file_size, file);
    fclose(file);
    
    if (bytes_read != file_size) {
        printf("Read error of font %s of size %llu, was read %llu bytes\n", in_path, file_size, bytes_read);
        return;
    }
    
    const int first_char = 32;
    const int stbtt_n = stbtt_BakeFontBitmap(ttf_buffer, 0, (float)pixel_height,
                                             bitmap, width, height,
                                             first_char, COUNT(cdata), cdata);

    if (stbtt_n == 0) {
        printf("No characters fit and no rows were used after font %s bitmap bake\n", in_path);
        return;
    }

    stbsp_snprintf(height_str, COUNT(height_str), "%d", pixel_height);
    
    const char *dot   = strrchr(in_path, '.');
    const char *slash = strrchr(in_path, '/') + 1;
    strncpy(name, slash, dot - slash);

    stbsp_snprintf(png_path, COUNT(png_path), "%s%s_%s%s", tex_dir, name, height_str, ".png");

    if (!stbi_write_png(png_path, width, abs(stbtt_n), 1, bitmap, width * sizeof(bitmap[0]))) {
        printf("Failed to write %s\n", png_path);
        return;
    }
    
    stbsp_snprintf(h_path, COUNT(h_path), "%s%s_%s%s", src_dir, name, height_str, ".h");

    stbtt_fontinfo font;
    if (!stbtt_InitFont(&font, ttf_buffer, 0)) {
        printf("Failed to load font %s\n", in_path);
        return;
    }

    int ascent, descent, line_gap;
    stbtt_GetFontVMetrics(&font, &ascent, &descent, &line_gap);

    const float px_h_scale = stbtt_ScaleForPixelHeight(&font, (float)pixel_height);
    const int line_height  = (int)((ascent - descent + line_gap) * px_h_scale);
    
    int p = 0;
    p += stbsp_snprintf(cdata_h + p, COUNT(cdata_h), "#pragma once\n\n");
    p += stbsp_snprintf(cdata_h + p, COUNT(cdata_h), "// This header was auto generated by internal font baker tool.\n// For more information, see src/tools/font_baker.cpp.\n\n");

    p += stbsp_snprintf(cdata_h + p, COUNT(cdata_h), "inline int %s_%s_start_charcode = %d;\n", name, height_str, first_char);
    p += stbsp_snprintf(cdata_h + p, COUNT(cdata_h), "inline int %s_%s_ascent = %d;\n", name, height_str, ascent);
    p += stbsp_snprintf(cdata_h + p, COUNT(cdata_h), "inline int %s_%s_descent = %d;\n", name, height_str, descent);
    p += stbsp_snprintf(cdata_h + p, COUNT(cdata_h), "inline int %s_%s_line_gap = %d;\n", name, height_str, line_gap);
    p += stbsp_snprintf(cdata_h + p, COUNT(cdata_h), "inline int %s_%s_line_height = %d;\n", name, height_str, line_height);
    p += stbsp_snprintf(cdata_h + p, COUNT(cdata_h), "inline float %s_%s_px_h_scale = %ff;\n\n", name, height_str, px_h_scale);
        
    p += stbsp_snprintf(cdata_h + p, COUNT(cdata_h), "inline struct { unsigned short x0,y0,x1,y1; float xoff,yoff,xadvance; } %s_%s_cdata[] = {\n", name, height_str);

    for (int i = 0; i < COUNT(cdata); ++i) {
        p += stbsp_snprintf(cdata_h + p, COUNT(cdata_h) - p, "{ .x0 = %d, .y0 = %d, .x1 = %d, .y1 = %d, .xoff = %ff, .yoff = %ff, .xadvance = %ff },\n",
                           cdata[i].x0, cdata[i].y0, cdata[i].x1, cdata[i].y1, cdata[i].xoff, cdata[i].yoff, cdata[i].xadvance);
    }
    strcat(cdata_h, "};\n");

    file = fopen(h_path, "w");
    if (!file) {
        printf("Failed to open %s\n", h_path);
        return;
    }

    const size_t cdata_size = strlen(cdata_h);
    const size_t bytes_written = fwrite(cdata_h, 1, cdata_size, file);
    if (bytes_written != cdata_size) {
        printf("Failed to write to %s\n", h_path);
        return;
    }

    fclose(file);

    const char *in_name  = strrchr(in_path,  '/') + 1;
    const char *png_name = strrchr(png_path, '/') + 1;
    const char *h_name   = strrchr(h_path,   '/') + 1;
    const int baked_glyph_count = stbtt_n > 0 ? COUNT(cdata) : abs(stbtt_n);
    printf("%s (%d) -> %s (%dx%d), %s (%d/%llu)\n",
           in_name, pixel_height,
           png_name, width, abs(stbtt_n),
           h_name, baked_glyph_count, COUNT(cdata));
}

#define FONT_PATH(x) "run_tree/data/fonts/"x

int main() {
    bake_font_atlas(FONT_PATH("better_vcr.ttf"), 16, 128, 128);
    bake_font_atlas(FONT_PATH("better_vcr.ttf"), 24, 256, 256);
    return 0;
}
